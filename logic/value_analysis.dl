// maximum depth of value analysis
#define VA_MAXDEPTH 10


// get possible integer values (wrapper, which supports constants as vreg)
.decl get_int_by_vreg(value: number, functionid: _functionid, _vreg: symbol)
.output get_int_by_vreg(delimiter=",")

// case initializing wrapper
get_int_by_vreg(VAL, FID, VREG) :-
    get_int_by_vreg_internal(VAL, FID, VREG, _, 1).

// case int supplied to get_int_by_vreg
get_int_by_vreg(VAL, FID, VREG) :-
    is_numeric(VREG),
    VAL = to_number(VREG),
    block(FID, _, _).


// get possible integer values
.decl get_int_by_vreg_internal(value: number,
                               functionid: _functionid,
                               vreg: symbol,
                               iidsetvalue: _instructionid,
                               depth: number)
.output get_int_by_vreg_internal(delimiter=",")

// case add VREG + INT
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "add",
    get_first_operand(IID, OV1),
    get_second_operand(IID, OV2),
    is_numeric(OV2),
    !is_numeric(OV1),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(TMP, FID, OV1, IID2, DEPTH+1),
    VAL=TMP+to_number(OV2).

 // case add VREG + VREG
  get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "add",
    get_first_operand(IID, OV1),
    get_second_operand(IID, OV2),
    !is_numeric(OV2),
    !is_numeric(OV1),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    is_instruction_before_other(IID, IID3), // IID2 is before IID
    get_int_by_vreg_internal(TMP1, FID, OV1, IID2, DEPTH+1),
    get_int_by_vreg_internal(TMP2, FID, OV2, IID3, DEPTH+1),
    VAL=TMP1+TMP2.

  //case sext
  get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "sext",
    get_first_operand(IID, OV1),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(VAL, FID, OV1, IID2, DEPTH+1).

// case mul: VREG * INT
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "mul",
    get_first_operand(IID, OV1),
    get_second_operand(IID, OV2),
    is_numeric(OV2),
    !is_numeric(OV1),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(TMP, FID, OV1, IID2, DEPTH+1),
    VAL=TMP*to_number(OV2).

// case sub: VREG - INT
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "sub",
    get_first_operand(IID, OV1),
    get_second_operand(IID, OV2),
    is_numeric(OV2),
    !is_numeric(OV1),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(TMP, FID, OV1, IID2, DEPTH+1),
    VAL=TMP-to_number(OV2).

// case sub: INT - VREG
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    !is_numeric(VREG),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "sub",
    get_first_operand(IID, OV1),
    get_second_operand(IID, OV2),
    is_numeric(OV1),
    !is_numeric(OV2),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(TMP, FID, OV2, IID2, DEPTH+1),
    VAL=to_number(OV1)-TMP.

// case store: VREG (int) -> VREG
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, _, OPC),
    OPC = "store",
    get_second_operand(IID, OV2),
    get_fourth_operand(IID, VREG),
    get_first_operand(IID, TYPE),
    is_inttype(TYPE),
    !is_numeric(OV2),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(VAL, FID, OV2, IID2, DEPTH+1).

// case load integer
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    get_third_operand(IID, OV3),
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "load",
    !is_numeric(OV3),
    is_instruction_before_other(IID, IID2), // IID2 is before IID
    get_int_by_vreg_internal(VAL, FID, OV3, IID2, DEPTH+1).

// speculative cases:

// case memequals
//get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
//    anumber(DEPTH),
//    DEPTH < VA_MAXDEPTH,
//    block(FID, BID, _),
//    instruction(BID, _, VREG, _),
//    instruction(BID, IID, START_LOC, _),
//    memequals(FID, START_LOC, FID2, END_LOC),
//    START_LOC = VREG,
//    //is_instruction_before_other(IID, IID2), // IID2 is before IID
//    //get_int_by_vreg_internal(VAL, FID2, END_LOC, IID2, DEPTH+1).
//    get_int_by_vreg_internal(VAL, FID2, END_LOC, _, DEPTH+1).

// case memequals oneway
//get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
//    anumber(DEPTH),
//    DEPTH < VA_MAXDEPTH,
//    block(FID, BID, _),
//    instruction(BID, _, VREG, _),
//    instruction(BID, IID, START_LOC, _),
//    memequals_oneway(FID, START_LOC, FID2, END_LOC),
//    START_LOC = VREG,
//    is_instruction_before_other(IID, IID2), // IID2 is before IID
//    get_int_by_vreg_internal(VAL, FID2, END_LOC, IID2, DEPTH+1).

// case call strlen (Maximum)
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    get_first_operand(IID, OV1),
    is_strlen_call_instruction(IID),
    get_buffsize_by_vreg(VAL2, FID, OV1),
    VAL = VAL2-1,
    VAL>0.

// case call atoi (max)
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    get_last_operand(IID, "atoi"),
    get_first_operand(IID, BUFFVREG),
    get_buffsize_by_vreg(THEORETICALBUFFSIZE, FID, BUFFVREG),
    BUFFSIZE = THEORETICALBUFFSIZE-1,
    x_nines(MAX, BUFFSIZE),
    VAL = to_number(MAX).

// case call atoi (min)
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    get_last_operand(IID, "atoi"),
    get_first_operand(IID, BUFFVREG),
    get_buffsize_by_vreg(THEORETICALBUFFSIZE, FID, BUFFVREG),
    BUFFSIZE = THEORETICALBUFFSIZE-1,
    BUFFSIZE > 1,
    x_nines(MIN, BUFFSIZE-1),
    MINSTR = cat("-", MIN),
    VAL = to_number(MINSTR).

// get core cases
get_int_by_vreg_internal(VAL, FID, VREG, IID, DEPTH) :-
    get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH).


// core includes all non-recursive cases, that can be directly identified
.decl get_int_by_vreg_internal_core(value: number,
                                    functionid: _functionid,
                                    vreg: symbol,
                                    iidsetvalue: _instructionid,
                                    depth: number)

// case store integer
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, _, OPC),
    OPC = "store",
    get_first_operand(IID, TYPE),
    get_second_operand(IID, OV2),
    get_fourth_operand(IID, VREG),
    is_inttype(TYPE),
    is_numeric(OV2),
    VAL = to_number(OV2).

// case load integer
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "load",
    get_third_operand(IID, OV2),
    is_numeric(OV2),
    VAL = to_number(OV2).

// speculative cases

// case phi instruction
// TODO: add case for non numeric LOC2 ?
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, "phi"),
    is_even(I),
    get_ith_operand(IID, I, LOC2),
    get_num_operands(IID, OPCOUNT),
    I<=OPCOUNT,
    !is_vreg(LOC2),
    is_numeric(LOC2),
    VAL = to_number(LOC2).

// case call strlen (TODO: Minimum with userinput (only) can be 0)
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    is_strlen_call_instruction(IID),
    VAL = 0.

// case rand max
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    get_last_operand(IID, "rand"),
    VAL = 32767.

// case rand min
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    block(FID, BID, _),
    instruction(BID, IID, VREG, OPC),
    OPC = "call",
    get_last_operand(IID, "rand"),
    VAL = 0.

// case userinput min
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    memlocation(FID, VREG, _, _),
    is_memloc_with_userinput(FID, VREG),
    IID = -1,
    VAL = 0.

// case userinput max unlimited
get_int_by_vreg_internal_core(VAL, FID, VREG, IID, DEPTH) :-
    anumber(DEPTH),
    DEPTH < VA_MAXDEPTH,
    taintlocation(FID, VREG, _, _),
    // CAT = cat("userinput_",to_string(MAXINT)),
    VAL = MAXINT,
    IID = -1.
