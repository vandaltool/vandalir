//points-to analysis
.decl points_to(functionid1: _functionid,
                memlocation1: symbol,
                functionid2: _functionid,
                memlocation2: symbol)
.output points_to(delimiter=",")

//memequals cases (not strictly necessary?)
//cases memequals: (s2 -> e && s2 <==> s) ==> s -> e
points_to(SFID, SLOC, EFID, ELOC) :-
    memequals(SFID, SLOC, S2FID, S2LOC),
    points_to(S2FID, S2LOC, EFID, ELOC).

//cases memequals: (s -> e2 && e2 <==> e) ==> s -> e
points_to(SFID, SLOC, EFID, ELOC) :-
    memequals(EFID, ELOC, E2FID, E2LOC),
    points_to(SFID, SLOC, E2FID, E2LOC).

//all others
points_to(SFID, SLOC, EFID, ELOC) :-
    points_to_core(SFID, SLOC, EFID, ELOC).

//case memequals: (s2 -> e2 && s2 <==> s && e2 <==> e) ==> s -> a
//probably this case is already covered by the two previous ones (?)
/*
points_to_core(SFID, SLOC, EFID, ELOC) :-
    points_to_core(S2FID, S2LOC, E2FID, E2LOC),
    memequals(SFID, SLOC, S2FID, S2LOC),
    memequals(EFID, ELOC, E2FID, E2LOC).
*/


.decl points_to_core(functionid1: _functionid,
                     memlocation1: symbol,
                     functionid2: _functionid,
                     memlocation2: symbol)
//.output points_to_core(delimiter=",")

//case store a pointer
points_to_core(SFID, SLOC, EFID, ELOC) :-
    get_store_pointer_by_iid(SFID, SLOC, IID),
    get_store_value_by_iid(EFID, ELOC, IID),
    is_store_instruction(IID),
    !is_numeric(ELOC).

//case load from vreg
points_to_core(SFID, SLOC, EFID, ELOC) :-
    memlocation(SFID, SLOC, _, _),
    memlocation(EFID, ELOC, _, _),
    instruction(BID, IID, VREG, "load"),
    get_load_pointer_by_iid(SFID, SLOC, IID),
    get_first_operand(IID, ETYPE),
    pointer_level(ETYPE, ETYPE_PLVL),
    ETYPE_PLVL >= 1, //do not consider pointers to actual values
    VREG = ELOC,
    block(EFID, BID, _).
